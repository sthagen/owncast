(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2888],{6840:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/_app",function(){return n(35913)}])},35913:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return App}});var o=n(85893);n(9166),n(52895),n(168),n(14248),n(89056);var r=n(4480);function App(e){var t;let{Component:n,pageProps:a}=e,i=null!==(t=n.getLayout)&&void 0!==t?t:e=>e;return i((0,o.jsx)(r.Wh,{children:(0,o.jsx)(n,{...a})}))}},9166:function(){},89056:function(){},14248:function(){},168:function(){},52895:function(){},34155:function(e){var t,n,o,r=e.exports={};function defaultSetTimout(){throw Error("setTimeout has not been defined")}function defaultClearTimeout(){throw Error("clearTimeout has not been defined")}function runTimeout(e){if(t===setTimeout)return setTimeout(e,0);if((t===defaultSetTimout||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(n){try{return t.call(null,e,0)}catch(n){return t.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout)return clearTimeout(e);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){t=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){n=defaultClearTimeout}}();var a=[],i=!1,l=-1;function cleanUpNextTick(){i&&o&&(i=!1,o.length?a=o.concat(a):l=-1,a.length&&drainQueue())}function drainQueue(){if(!i){var e=runTimeout(cleanUpNextTick);i=!0;for(var t=a.length;t;){for(o=a,a=[];++l<t;)o&&o[l].run();l=-1,t=a.length}o=null,i=!1,runClearTimeout(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}r.nextTick=function(e){var t=Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];a.push(new Item(e,t)),1!==a.length||i||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=noop,r.addListener=noop,r.once=noop,r.off=noop,r.removeListener=noop,r.removeAllListeners=noop,r.emit=noop,r.prependListener=noop,r.prependOnceListener=noop,r.listeners=function(e){return[]},r.binding=function(e){throw Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw Error("process.chdir is not supported")},r.umask=function(){return 0}},4480:function(e,t,n){"use strict";let o;n.d(t,{FV:function(){return o3},Wh:function(){return o5},Zl:function(){return o6},cn:function(){return o4},nZ:function(){return o8},sJ:function(){return o9},zl:function(){return o2}});var r,a,i,l,s=n(67294),u=n(73935),c=n(34155),err_1=function(e){let t=Error(e);if(void 0===t.stack)try{throw t}catch(e){}return t},Recoil_isPromise=function(e){return!!e&&"function"==typeof e.then},Recoil_nullthrows=function(e,t){if(null!=e)return e;throw err_1(null!=t?t:"Got unexpected null or undefined")};function _defineProperty(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}let BaseLoadable=class BaseLoadable{getValue(){throw err_1("BaseLoadable")}toPromise(){throw err_1("BaseLoadable")}valueMaybe(){throw err_1("BaseLoadable")}valueOrThrow(){throw err_1(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw err_1("BaseLoadable")}promiseOrThrow(){throw err_1(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw err_1("BaseLoadable")}errorOrThrow(){throw err_1(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw err_1("BaseLoadable")}};let ValueLoadable=class ValueLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","hasValue"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{let t=e(this.contents);return Recoil_isPromise(t)?loadableWithPromise(t):isLoadable(t)?t:loadableWithValue(t)}catch(t){return Recoil_isPromise(t)?loadableWithPromise(t.next(()=>this.map(e))):loadableWithError(t)}}};let ErrorLoadable=class ErrorLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","hasError"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}};let LoadingLoadable=class LoadingLoadable extends BaseLoadable{constructor(e){super(),_defineProperty(this,"state","loading"),_defineProperty(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return loadableWithPromise(this.contents.then(t=>{let n=e(t);if(isLoadable(n))switch(n.state){case"hasValue":case"loading":return n.contents;case"hasError":throw n.contents}return n}).catch(t=>{if(Recoil_isPromise(t))return t.then(()=>this.map(e).contents);throw t}))}};function loadableWithValue(e){return Object.freeze(new ValueLoadable(e))}function loadableWithError(e){return Object.freeze(new ErrorLoadable(e))}function loadableWithPromise(e){return Object.freeze(new LoadingLoadable(e))}function loadableLoading(){return Object.freeze(new LoadingLoadable(new Promise(()=>{})))}function loadableAllArray(e){return e.every(e=>"hasValue"===e.state)?loadableWithValue(e.map(e=>e.contents)):e.some(e=>"hasError"===e.state)?loadableWithError(Recoil_nullthrows(e.find(e=>"hasError"===e.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(e.map(e=>e.contents)))}function loadableAll(e){let t=Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t]),n=t.map(e=>isLoadable(e)?e:Recoil_isPromise(e)?loadableWithPromise(e):loadableWithValue(e)),o=loadableAllArray(n);return Array.isArray(e)?o:o.map(t=>Object.getOwnPropertyNames(e).reduce((e,n,o)=>({...e,[n]:t[o]}),{}))}function isLoadable(e){return e instanceof BaseLoadable}var d={loadableWithValue,loadableWithError,loadableWithPromise,loadableLoading,loadableAll,isLoadable,RecoilLoadable:{of:e=>Recoil_isPromise(e)?loadableWithPromise(e):isLoadable(e)?e:loadableWithValue(e),error:e=>loadableWithError(e),loading:()=>loadableLoading(),all:loadableAll,isLoadable}},f=Object.freeze({__proto__:null,loadableWithValue:d.loadableWithValue,loadableWithError:d.loadableWithError,loadableWithPromise:d.loadableWithPromise,loadableLoading:d.loadableLoading,loadableAll:d.loadableAll,isLoadable:d.isLoadable,RecoilLoadable:d.RecoilLoadable});let h={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function readProcessEnvBooleanFlag(e,t){var n,o;let r=null===(n=c.env[e])||void 0===n?void 0:null===(o=n.toLowerCase())||void 0===o?void 0:o.trim();if(null!=r&&""!==r){if(!["true","false"].includes(r))throw err_1(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t("true"===r)}}function readProcessEnvStringArrayFlag(e,t){var n;let o=null===(n=c.env[e])||void 0===n?void 0:n.trim();null!=o&&""!==o&&t(o.split(/\s*,\s*|\s+/))}function Recoil_gkx_OSS(e){return h.RECOIL_GKS_ENABLED.has(e)}void 0!==c&&(null==c?void 0:c.env)!=null&&(readProcessEnvBooleanFlag("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",e=>{h.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=e}),readProcessEnvStringArrayFlag("RECOIL_GKS_ENABLED",e=>{e.forEach(e=>{h.RECOIL_GKS_ENABLED.add(e)})})),Recoil_gkx_OSS.setPass=e=>{h.RECOIL_GKS_ENABLED.add(e)},Recoil_gkx_OSS.setFail=e=>{h.RECOIL_GKS_ENABLED.delete(e)},Recoil_gkx_OSS.clear=()=>{h.RECOIL_GKS_ENABLED.clear()};var p=Recoil_gkx_OSS,recoverableViolation_1=function(e,t,{error:n}={}){return null};let _=null!==(a=s.createMutableSource)&&void 0!==a?a:s.unstable_createMutableSource,m=null!==(i=s.useMutableSource)&&void 0!==i?i:s.unstable_useMutableSource,y=null!==(l=s.useSyncExternalStore)&&void 0!==l?l:s.unstable_useSyncExternalStore,S=!1;function currentRendererSupportsUseSyncExternalStore(){var e;let{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,o=null!==(e=null==t?void 0:t.current)&&void 0!==e?e:n.currentDispatcher,r=null!=o.useSyncExternalStore;return!y||r||S||(S=!0,recoverableViolation_1("A React renderer without React 18+ API support is being used with React 18+.")),r}function reactMode(){return p("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:p("recoil_sync_external_store")&&null!=y?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:p("recoil_mutable_source")&&null!=m&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?p("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:p("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}var v={createMutableSource:_,useMutableSource:m,useSyncExternalStore:y,currentRendererSupportsUseSyncExternalStore,reactMode,isFastRefreshEnabled:function(){return!1}};let AbstractRecoilValue=class AbstractRecoilValue{constructor(e){_defineProperty(this,"key",void 0),this.key=e}toJSON(){return{key:this.key}}};let RecoilState=class RecoilState extends AbstractRecoilValue{};let RecoilValueReadOnly=class RecoilValueReadOnly extends AbstractRecoilValue{};function isRecoilValue(e){return e instanceof RecoilState||e instanceof RecoilValueReadOnly}var R={AbstractRecoilValue,RecoilState,RecoilValueReadOnly,isRecoilValue},g=Object.freeze({__proto__:null,AbstractRecoilValue:R.AbstractRecoilValue,RecoilState:R.RecoilState,RecoilValueReadOnly:R.RecoilValueReadOnly,isRecoilValue:R.isRecoilValue}),expectationViolation_1=function(e,...t){},Recoil_mapIterable=function(e,t){return function*(){let n=0;for(let o of e)yield t(o,n++)}()};let{isFastRefreshEnabled:b}=v;let DefaultValue=class DefaultValue{};let T=new DefaultValue,w=new Map,A=new Map;function recoilValuesForKeys(e){return Recoil_mapIterable(e,e=>Recoil_nullthrows(A.get(e)))}function checkForDuplicateAtomKey(e){if(w.has(e)){let t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function registerNode(e){h.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&checkForDuplicateAtomKey(e.key),w.set(e.key,e);let t=null==e.set?new g.RecoilValueReadOnly(e.key):new g.RecoilState(e.key);return A.set(e.key,t),t}let NodeMissingError=class NodeMissingError extends Error{};function getNode(e){let t=w.get(e);if(null==t)throw new NodeMissingError(`Missing definition for RecoilValue: "${e}""`);return t}function getNodeMaybe(e){return w.get(e)}let E=new Map;function deleteNodeConfigIfPossible(e){var t,n;if(!p("recoil_memory_managament_2020"))return;let o=w.get(e);null!=o&&null!==(t=o.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(o)&&(w.delete(e),null===(n=getConfigDeletionHandler(e))||void 0===n||n(),E.delete(e))}function getConfigDeletionHandler(e){return E.get(e)}var N={nodes:w,recoilValues:A,registerNode,getNode,getNodeMaybe,deleteNodeConfigIfPossible,setConfigDeletionHandler:function(e,t){p("recoil_memory_managament_2020")&&(void 0===t?E.delete(e):E.set(e,t))},getConfigDeletionHandler,recoilValuesForKeys,NodeMissingError,DefaultValue,DEFAULT_VALUE:T},L={enqueueExecution:function(e,t){t()}},V=(function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o={},constant=function(e){return function(){return e}},r=n.hash=function(e){var n=void 0===e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},hashFragment=function(e,t){return t>>>e&31},toBitmap=function(e){return 1<<e},fromBitmap=function(e,t){var n;return n=e&t-1,n-=n>>1&1431655765,n=(n=(858993459&n)+(n>>2&858993459))+(n>>4)&252645135,n+=n>>8,127&(n+=n>>16)},arrayUpdate=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=Array(a);for(var i=0;i<a;++i)r[i]=o[i]}return r[t]=n,r},arraySpliceOut=function(e,t,n){var o=n.length-1,r=0,a=0,i=n;if(e)r=a=t;else for(i=Array(o);r<t;)i[a++]=n[r++];for(++r;r<=o;)i[a++]=n[r++];return e&&(i.length=o),i},arraySpliceIn=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var i=0,l=0,s=Array(r+1);i<t;)s[l++]=o[i++];for(s[t]=n;i<r;)s[++l]=o[i++];return s},a={__hamt_isEmpty:!0},isEmptyNode=function(e){return e===a||e&&e.__hamt_isEmpty},Leaf=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:Leaf__modify}},Collision=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:Collision__modify}},IndexedNode=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:IndexedNode__modify}},ArrayNode=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:ArrayNode__modify}},expand=function(e,t,n,o,r){for(var a=[],i=o,l=0,s=0;i;++s)1&i&&(a[s]=r[l++]),i>>>=1;return a[t]=n,ArrayNode(e,l+1,a)},pack=function(e,t,n,o){for(var r=Array(t-1),a=0,i=0,l=0,s=o.length;l<s;++l)if(l!==n){var u=o[l];u&&!isEmptyNode(u)&&(r[a++]=u,i|=1<<l)}return IndexedNode(e,i,r)},mergeLeaves=function mergeLeaves(e,t,n,o,r,a){if(n===r)return Collision(e,n,[a,o]);var i=hashFragment(t,n),l=hashFragment(t,r);return IndexedNode(e,toBitmap(i)|toBitmap(l),i===l?[mergeLeaves(e,t+5,n,o,r,a)]:i<l?[o,a]:[a,o])},updateCollisionList=function(e,t,n,r,a,i,l,s){for(var u=a.length,c=0;c<u;++c){var d=a[c];if(n(l,d.key)){var f=d.value,h=i(f);if(h===f)return a;if(h===o)return--s.value,arraySpliceOut(e,c,a);return arrayUpdate(e,c,Leaf(t,r,l,h),a)}}var p=i();return p===o?a:(++s.value,arrayUpdate(e,u,Leaf(t,r,l,p),a))},canEditNode=function(e,t){return e===t.edit},Leaf__modify=function(e,t,n,r,i,l,s){if(t(l,this.key)){var u=r(this.value);return u===this.value?this:u===o?(--s.value,a):canEditNode(e,this)?(this.value=u,this):Leaf(e,i,l,u)}var c=r();return c===o?this:(++s.value,mergeLeaves(e,n,this.hash,this,i,Leaf(e,i,l,c)))},Collision__modify=function(e,t,n,r,a,i,l){if(a===this.hash){var s=updateCollisionList(canEditNode(e,this),e,t,this.hash,this.children,r,i,l);return s===this.children?this:s.length>1?Collision(e,this.hash,s):s[0]}var u=r();return u===o?this:(++l.value,mergeLeaves(e,n,this.hash,this,a,Leaf(e,a,i,u)))},IndexedNode__modify=function(e,t,n,o,r,i,l){var s,u=this.mask,c=this.children,d=hashFragment(n,r),f=toBitmap(d),h=fromBitmap(u,f),p=u&f,_=p?c[h]:a,m=_._modify(e,t,n+5,o,r,i,l);if(_===m)return this;var y=canEditNode(e,this),S=u,v=void 0;if(p&&isEmptyNode(m)){if(!(S&=~f))return a;if(c.length<=2&&((s=c[1^h])===a||1===s.type||2===s.type))return c[1^h];v=arraySpliceOut(y,h,c)}else if(p||isEmptyNode(m))v=arrayUpdate(y,h,m,c);else{if(c.length>=16)return expand(e,d,m,u,c);S|=f,v=arraySpliceIn(y,h,m,c)}return y?(this.mask=S,this.children=v,this):IndexedNode(e,S,v)},ArrayNode__modify=function(e,t,n,o,r,i,l){var s=this.size,u=this.children,c=hashFragment(n,r),d=u[c],f=(d||a)._modify(e,t,n+5,o,r,i,l);if(d===f)return this;var h=canEditNode(e,this),p=void 0;if(isEmptyNode(d)&&!isEmptyNode(f))++s,p=arrayUpdate(h,c,f,u);else if(!isEmptyNode(d)&&isEmptyNode(f)){if(--s<=8)return pack(e,s,c,u);p=arrayUpdate(h,c,a,u)}else p=arrayUpdate(h,c,f,u);return h?(this.size=s,this.children=p,this):ArrayNode(e,s,p)};function Map(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}a._modify=function(e,t,n,r,i,l,s){var u=r();return u===o?a:(++s.value,Leaf(e,i,l,u))},Map.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new Map(this._editable,this._edit,this._config,e,t)};var i=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,i=o._config.keyEq;;)switch(r.type){case 1:return i(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var l=r.children,s=0,u=l.length;s<u;++s){var c=l[s];if(i(n,c.key))return c.value}return e;case 3:var d=toBitmap(hashFragment(a,t));if(r.mask&d){r=r.children[fromBitmap(r.mask,d)],a+=5;break}return e;case 4:if(r=r.children[hashFragment(a,t)]){a+=5;break}return e;default:return e}};Map.prototype.tryGetHash=function(e,t,n){return i(e,t,n,this)};var l=n.tryGet=function(e,t,n){return i(e,n._config.hash(t),t,n)};Map.prototype.tryGet=function(e,t){return l(e,t,this)};var s=n.getHash=function(e,t,n){return i(void 0,e,t,n)};Map.prototype.getHash=function(e,t){return s(e,t,this)},n.get=function(e,t){return i(void 0,t._config.hash(e),e,t)},Map.prototype.get=function(e,t){return l(t,e,this)};var u=n.has=function(e,t,n){return i(o,e,t,n)!==o};Map.prototype.hasHash=function(e,t){return u(e,t,this)};var c=n.has=function(e,t){return u(t._config.hash(e),e,t)};Map.prototype.has=function(e){return c(e,this)};var defKeyCompare=function(e,t){return e===t};n.make=function(e){return new Map(0,0,{keyEq:e&&e.keyEq||defKeyCompare,hash:e&&e.hash||r},a,0)},n.empty=n.make();var d=n.isEmpty=function(e){return e&&!!isEmptyNode(e._root)};Map.prototype.isEmpty=function(){return d(this)};var f=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};Map.prototype.modifyHash=function(e,t,n){return f(n,e,t,this)};var h=n.modify=function(e,t,n){return f(e,n._config.hash(t),t,n)};Map.prototype.modify=function(e,t){return h(t,e,this)};var p=n.setHash=function(e,t,n,o){return f(constant(n),e,t,o)};Map.prototype.setHash=function(e,t,n){return p(e,t,n,this)};var _=n.set=function(e,t,n){return p(n._config.hash(e),e,t,n)};Map.prototype.set=function(e,t){return _(e,t,this)};var m=constant(o),y=n.removeHash=function(e,t,n){return f(m,e,t,n)};Map.prototype.removeHash=Map.prototype.deleteHash=function(e,t){return y(e,t,this)};var S=n.remove=function(e,t){return y(t._config.hash(e),e,t)};Map.prototype.remove=Map.prototype.delete=function(e){return S(e,this)};var v=n.beginMutation=function(e){return new Map(e._editable+1,e._edit+1,e._config,e._root,e._size)};Map.prototype.beginMutation=function(){return v(this)};var R=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};Map.prototype.endMutation=function(){return R(this)};var g=n.mutate=function(e,t){var n=v(t);return e(n),R(n)};Map.prototype.mutate=function(e){return g(e,this)};var appk=function(e){return e&&lazyVisitChildren(e[0],e[1],e[2],e[3],e[4])},lazyVisitChildren=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!isEmptyNode(a))return lazyVisit(a,o,[e,t,n,o,r])}return appk(r)},lazyVisit=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return lazyVisitChildren(o.length,o,0,t,n);default:return appk(n)}},b={done:!0};function MapIterator(e){this.v=e}MapIterator.prototype.next=function(){if(!this.v)return b;var e=this.v;return this.v=appk(e.rest),e},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function(e,t){return new MapIterator(lazyVisit(e._root,t))},buildPairs=function(e){return[e.key,e.value]},T=n.entries=function(e){return visit(e,buildPairs)};Map.prototype.entries=Map.prototype[Symbol.iterator]=function(){return T(this)};var buildKeys=function(e){return e.key},w=n.keys=function(e){return visit(e,buildKeys)};Map.prototype.keys=function(){return w(this)};var buildValues=function(e){return e.value},A=n.values=Map.prototype.values=function(e){return visit(e,buildValues)};Map.prototype.values=function(){return A(this)};var E=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var i=0,l=a.length;i<l;){var s=a[i++];s&&s.type&&(1===s.type?t=e(t,s.value,s.key):r.push(s.children))}return t};Map.prototype.fold=function(e,t){return E(e,t,this)};var N=n.forEach=function(e,t){return E(function(n,o,r){return e(o,r,t)},null,t)};Map.prototype.forEach=function(e){return N(e,this)};var L=n.count=function(e){return e._size};Map.prototype.count=function(){return L(this)},Object.defineProperty(Map.prototype,"size",{get:Map.prototype.count}),e.exports?e.exports=n:undefined.hamt=n}(r={exports:{}},r.exports),r.exports);let BuiltInMap=class BuiltInMap{constructor(e){_defineProperty(this,"_map",void 0),this._map=new Map(null==e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}};let HashArrayMappedTrieMap=class HashArrayMappedTrieMap{constructor(e){if(_defineProperty(this,"_hamt",V.empty.beginMutation()),e instanceof HashArrayMappedTrieMap){let t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(let[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}};function persistentMap(e){return p("recoil_hamt_2020")?new HashArrayMappedTrieMap(e):new BuiltInMap(e)}var C=Object.freeze({__proto__:null,persistentMap:{persistentMap}.persistentMap}),Recoil_differenceSets=function(e,...t){let n=new Set;e:for(let o of e){for(let e of t)if(e.has(o))continue e;n.add(o)}return n},Recoil_mapMap=function(e,t){let n=new Map;return e.forEach((e,o)=>{n.set(o,t(e,o))}),n};function mergeDepsIntoGraph(e,t,n,o){let{nodeDeps:r,nodeToNodeSubscriptions:a}=n,i=r.get(e);if(i&&o&&i!==o.nodeDeps.get(e))return;r.set(e,t);let l=null==i?t:Recoil_differenceSets(t,i);for(let t of l){a.has(t)||a.set(t,new Set);let n=Recoil_nullthrows(a.get(t));n.add(e)}if(i){let n=Recoil_differenceSets(i,t);for(let t of n){if(!a.has(t))return;let n=Recoil_nullthrows(a.get(t));n.delete(e),0===n.size&&a.delete(t)}}}var k={cloneGraph:function(e){return{nodeDeps:Recoil_mapMap(e.nodeDeps,e=>new Set(e)),nodeToNodeSubscriptions:Recoil_mapMap(e.nodeToNodeSubscriptions,e=>new Set(e))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},saveDepsToStore:function(e,t,n,o){var r,a,i,l,s;let u=n.getState();o===u.currentTree.version||o===(null===(r=u.nextTree)||void 0===r?void 0:r.version)||o===(null===(a=u.previousTree)||void 0===a?void 0:a.version)||recoverableViolation_1("Tried to save dependencies to a discarded tree");let c=n.getGraph(o);if(mergeDepsIntoGraph(e,t,c),o===(null===(i=u.previousTree)||void 0===i?void 0:i.version)){let o=n.getGraph(u.currentTree.version);mergeDepsIntoGraph(e,t,o,c)}if(o===(null===(l=u.previousTree)||void 0===l?void 0:l.version)||o===u.currentTree.version){let o=null===(s=u.nextTree)||void 0===s?void 0:s.version;if(void 0!==o){let r=n.getGraph(o);mergeDepsIntoGraph(e,t,r,c)}}}};let I=0,P=0,M=0;var U={getNextTreeStateVersion:()=>I++,getNextStoreID:()=>P++,getNextComponentID:()=>M++};let{persistentMap:O}=C,{graph:D}=k,{getNextTreeStateVersion:B}=U;function makeEmptyTreeState(){let e=B();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:O(),nonvalidatedAtoms:O()}}function makeEmptyStoreState(){let e=makeEmptyTreeState();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,D()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var x={makeEmptyTreeState,makeEmptyStoreState,getNextTreeStateVersion:B};let RetentionZone=class RetentionZone{};function retentionZone(){return new RetentionZone}var F={RetentionZone,retentionZone},z={setByAddingToSet:function(e,t){let n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){let n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){let o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){let o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){let n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){let n=new Map(e);return t.forEach(e=>n.delete(e)),n}},Recoil_filterIterable=function*(e,t){let n=0;for(let o of e)t(o,n++)&&(yield o)},Recoil_lazyProxy=function(e,t){let n=new Proxy(e,{get:(e,n)=>(!(n in e)&&n in t&&(e[n]=t[n]()),e[n]),ownKeys:e=>Object.keys(e)});return n};let{getNode:W,getNodeMaybe:G,recoilValuesForKeys:$}=N,{RetentionZone:H}=F,{setByAddingToSet:K}=z,q=Object.freeze(new Set);let ReadOnlyRecoilValueError=class ReadOnlyRecoilValueError extends Error{};function initializeRetentionForNode(e,t,n){if(!p("recoil_memory_managament_2020"))return()=>void 0;let{nodesRetainedByZone:o}=e.getState().retention;function addToZone(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof H)addToZone(n);else if(Array.isArray(n))for(let e of n)addToZone(e);return()=>{if(!p("recoil_memory_managament_2020"))return;let{retention:o}=e.getState();function deleteFromZone(e){let n=o.nodesRetainedByZone.get(e);null==n||n.delete(t),n&&0===n.size&&o.nodesRetainedByZone.delete(e)}if(n instanceof H)deleteFromZone(n);else if(Array.isArray(n))for(let e of n)deleteFromZone(e)}}function initializeNodeIfNewToStore(e,t,n,o){let r=e.getState();if(r.nodeCleanupFunctions.has(n))return;let a=W(n),i=initializeRetentionForNode(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),i()})}function peekNodeLoadable(e,t,n){return W(n).peek(e,t)}function peekNodeInfo(e,t,n){let o=e.getState(),r=e.getGraph(t.version),a=W(n).nodeType;return Recoil_lazyProxy({type:a},{loadable:()=>peekNodeLoadable(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>"selector"!==a&&t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var e;return $(null!==(e=r.nodeDeps.get(n))&&void 0!==e?e:[])},subscribers:()=>{var r,a;return{nodes:$(Recoil_filterIterable(getDownstreamNodes(e,t,new Set([n])),e=>e!==n)),components:Recoil_mapIterable(null!==(r=null===(a=o.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],([e])=>({name:e}))}}})}function getDownstreamNodes(e,t,n){let o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let e=r.pop();e;e=r.pop()){var i;o.add(e);let t=null!==(i=a.nodeToNodeSubscriptions.get(e))&&void 0!==i?i:q;for(let e of t)o.has(e)||r.push(e)}return o}var j={getNodeLoadable:function(e,t,n){return initializeNodeIfNewToStore(e,t,n,"get"),W(n).get(e,t)},peekNodeLoadable,setNodeValue:function(e,t,n,o){let r=W(n);if(null==r.set)throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${n}`);let a=r.set;return initializeNodeIfNewToStore(e,t,n,"set"),a(e,t,o)},initializeNode:function(e,t,n){initializeNodeIfNewToStore(e,e.getState().currentTree,t,n)},cleanUpNode:function(e,t){var n;let o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;let r=G(t);return null==r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:K(e.dirtyAtoms,t)}},peekNodeInfo,getDownstreamNodes};let Z=null;var Y={setInvalidateMemoizedSnapshot:function(e){Z=e},invalidateMemoizedSnapshot:function(){var e;null===(e=Z)||void 0===e||e()}};let{getDownstreamNodes:J,getNodeLoadable:X,setNodeValue:Q}=j,{getNextComponentID:ee}=U,{getNode:et,getNodeMaybe:en}=N,{DefaultValue:eo}=N,{reactMode:er}=v,{AbstractRecoilValue:ea,RecoilState:ei,RecoilValueReadOnly:el,isRecoilValue:es}=g,{invalidateMemoizedSnapshot:eu}=Y;function getRecoilValueAsLoadable(e,{key:t},n=e.getState().currentTree){var o,r;let a=e.getState();n.version===a.currentTree.version||n.version===(null===(o=a.nextTree)||void 0===o?void 0:o.version)||n.version===(null===(r=a.previousTree)||void 0===r?void 0:r.version)||recoverableViolation_1("Tried to read from a discarded tree");let i=X(e,n,t);return"loading"===i.state&&i.contents.catch(()=>{}),i}function applyAtomValueWrites(e,t){let n=e.clone();return t.forEach((e,t)=>{"hasValue"===e.state&&e.contents instanceof eo?n.delete(t):n.set(t,e)}),n}function valueFromValueOrUpdater(e,t,{key:n},o){if("function"!=typeof o)return o;{let r=X(e,t,n);if("loading"===r.state){let e=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw recoverableViolation_1(e),err_1(e)}if("hasError"===r.state)throw r.contents;return o(r.contents)}}function applyAction(e,t,n){if("set"===n.type){let{recoilValue:o,valueOrUpdater:r}=n,a=valueFromValueOrUpdater(e,t,o,r),i=Q(e,t,o.key,a);for(let[e,n]of i.entries())writeLoadableToTreeState(t,e,n)}else if("setLoadable"===n.type){let{recoilValue:{key:e},loadable:o}=n;writeLoadableToTreeState(t,e,o)}else if("markModified"===n.type){let{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;let{recoilValue:{key:e},unvalidatedValue:r}=n,a=en(e);null==a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else recoverableViolation_1(`Unknown action ${n.type}`)}function writeLoadableToTreeState(e,t,n){"hasValue"===n.state&&n.contents instanceof eo?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function applyActionsToStore(e,t){e.replaceState(n=>{let o=copyTreeState(n);for(let n of t)applyAction(e,o,n);return invalidateDownstreams(e,o),eu(),o})}function queueOrPerformStateUpdate(e,t){if(ec.length){let n=ec[ec.length-1],o=n.get(e);o||n.set(e,o=[]),o.push(t)}else applyActionsToStore(e,[t])}let ec=[];function copyTreeState(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function invalidateDownstreams(e,t){let n=J(e,t,t.dirtyAtoms);for(let e of n){var o,r;null===(o=en(e))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function setRecoilValue(e,t,n){queueOrPerformStateUpdate(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function setRecoilValueLoadable(e,t,n){if(n instanceof eo)return setRecoilValue(e,t,n);queueOrPerformStateUpdate(e,{type:"setLoadable",recoilValue:t,loadable:n})}var ed={RecoilValueReadOnly:el,AbstractRecoilValue:ea,RecoilState:ei,getRecoilValueAsLoadable,setRecoilValue,setRecoilValueLoadable,markRecoilValueModified:function(e,t){queueOrPerformStateUpdate(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){queueOrPerformStateUpdate(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){let r=ee(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),Recoil_nullthrows(a.nodeToComponentSubscriptions.get(t)).set(r,[null!=o?o:"<not captured>",n]);let i=er();if(i.early&&("LEGACY"===i.mode||"MUTABLE_SOURCE"===i.mode)){let o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{let n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);if(void 0===o||!o.has(r)){recoverableViolation_1(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);return}o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)}}},isRecoilValue:es,applyAtomValueWrites,batchStart:function(){let e=new Map;return ec.push(e),()=>{for(let[t,n]of e)applyActionsToStore(t,n);let t=ec.pop();t!==e&&recoverableViolation_1("Incorrect order of batch popping")}},writeLoadableToTreeState,invalidateDownstreams,copyTreeState,refreshRecoilValue:function(e,t){var n;let{currentTree:o}=e.getState(),r=et(t.key);null===(n=r.clearCache)||void 0===n||n.call(r,e,o)}},Recoil_someSet=function(e,t,n){let o=e.entries(),r=o.next();for(;!r.done;){let a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};let{cleanUpNode:ef}=j,{deleteNodeConfigIfPossible:eh,getNode:ep}=N,{RetentionZone:e_}=F,em=new Set;function releaseRetainablesNowOnCurrentTree(e,t){let n=e.getState(),o=n.currentTree;if(n.nextTree){recoverableViolation_1("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let r=new Set;for(let e of t)if(e instanceof e_)for(let t of nodesRetainedByZone(n,e))r.add(t);else r.add(e);let a=findReleasableNodes(e,r);for(let t of a)releaseNode(e,o,t)}function findReleasableNodes(e,t){let n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return findReleasableNodesInner(t),a;function findReleasableNodesInner(t){var l,s;let u=new Set,c=getDownstreamNodesInTopologicalOrder(e,o,t,a,i);for(let e of c){if("recoilRoot"===ep(e).retainedBy||(null!==(l=n.retention.referenceCounts.get(e))&&void 0!==l?l:0)>0||zonesThatCouldRetainNode(e).some(e=>n.retention.referenceCounts.get(e))){i.add(e);continue}let t=r.nodeToNodeSubscriptions.get(e);if(t&&Recoil_someSet(t,e=>i.has(e))){i.add(e);continue}a.add(e),u.add(e)}let d=new Set;for(let e of u)for(let t of null!==(s=r.nodeDeps.get(e))&&void 0!==s?s:em)a.has(t)||d.add(t);d.size&&findReleasableNodesInner(d)}}function getDownstreamNodesInTopologicalOrder(e,t,n,o,r){let a=e.getGraph(t.version),i=[],l=new Set;for(;n.size>0;)visit(Recoil_nullthrows(n.values().next().value));return i;function visit(e){if(o.has(e)||r.has(e)){n.delete(e);return}if(l.has(e))return;let t=a.nodeToNodeSubscriptions.get(e);if(t)for(let e of t)visit(e);l.add(e),n.delete(e),i.push(e)}}function releaseNode(e,t,n){var o,r;if(!p("recoil_memory_managament_2020"))return;ef(e,n);let a=e.getState();a.knownAtoms.delete(n),a.knownSelectors.delete(n),a.nodeTransactionSubscriptions.delete(n),a.retention.referenceCounts.delete(n);let i=zonesThatCouldRetainNode(n);for(let e of i)null===(o=a.retention.nodesRetainedByZone.get(e))||void 0===o||o.delete(n);t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);let l=a.graphsByVersion.get(t.version);if(l){let e=l.nodeDeps.get(n);if(void 0!==e)for(let t of(l.nodeDeps.delete(n),e))null===(r=l.nodeToNodeSubscriptions.get(t))||void 0===r||r.delete(n);l.nodeToNodeSubscriptions.delete(n)}eh(n)}function nodesRetainedByZone(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:em}function zonesThatCouldRetainNode(e){let t=ep(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof e_?[t]:t}function scheduleOrPerformPossibleReleaseOfRetainable(e,t){let n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):releaseRetainablesNowOnCurrentTree(e,new Set([t]))}function updateRetainCountToZero(e,t){if(!p("recoil_memory_managament_2020"))return;let n=e.getState().retention.referenceCounts;n.delete(t),scheduleOrPerformPossibleReleaseOfRetainable(e,t)}var ey={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!p("recoil_memory_managament_2020"))return;let r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?updateRetainCountToZero(e,t):r.set(t,a)},updateRetainCountToZero,releaseScheduledRetainablesNow:function(e){if(!p("recoil_memory_managament_2020"))return;let t=e.getState();releaseRetainablesNowOnCurrentTree(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};let{unstable_batchedUpdates:eS}=u,{unstable_batchedUpdates:ev}={unstable_batchedUpdates:eS},{batchStart:eR}=ed,{unstable_batchedUpdates:eg}={unstable_batchedUpdates:ev},eb=eg||(e=>e());var eT={getBatcher:()=>eb,setBatcher:e=>{eb=e},batchUpdates:e=>{eb(()=>{let batchEnd=()=>void 0;try{batchEnd=eR(),e()}finally{batchEnd()}})}},Recoil_concatIterables=function*(e){for(let t of e)for(let e of t)yield e};let ew="undefined"==typeof Window||"undefined"==typeof window,eA="undefined"!=typeof navigator&&"ReactNative"===navigator.product;var eE={isSSR:ew,isReactNative:eA,isWindow:e=>!ew&&(e===window||e instanceof Window)};function memoizeWithArgsHash(e,t){let n;return(...o)=>{n||(n={});let r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function memoizeOneWithArgsHash(e,t){let n,o;return(...r)=>{let a=t(...r);return n===a?o:(n=a,o=e(...r))}}function memoizeOneWithArgsHashAndInvalidation(e,t){let n,o;return[(...r)=>{let a=t(...r);return n===a?o:(n=a,o=e(...r))},()=>{n=null}]}let{batchUpdates:eN}=eT,{initializeNode:eL,peekNodeInfo:eV}=j,{graph:eC}=k,{getNextStoreID:ek}=U,{DEFAULT_VALUE:eI,recoilValues:eP,recoilValuesForKeys:eM}=N,{AbstractRecoilValue:eU,getRecoilValueAsLoadable:eO,setRecoilValue:eD,setUnvalidatedRecoilValue:eB}=ed,{updateRetainCount:ex}=ey,{setInvalidateMemoizedSnapshot:eF}=Y,{getNextTreeStateVersion:ez,makeEmptyStoreState:eW}=x,{isSSR:eG}=eE,{memoizeOneWithArgsHashAndInvalidation:e$}={memoizeWithArgsHash,memoizeOneWithArgsHash,memoizeOneWithArgsHashAndInvalidation};let Snapshot=class Snapshot{constructor(e,t){for(let n of(_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",1),_defineProperty(this,"getLoadable",e=>(this.checkRefCount_INTERNAL(),eO(this._store,e))),_defineProperty(this,"getPromise",e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise())),_defineProperty(this,"getNodes_UNSTABLE",e=>{if(this.checkRefCount_INTERNAL(),(null==e?void 0:e.isModified)===!0){if((null==e?void 0:e.isInitialized)===!1)return[];let t=this._store.getState().currentTree;return eM(t.dirtyAtoms)}let t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return(null==e?void 0:e.isInitialized)==null?eP.values():!0===e.isInitialized?eM(Recoil_concatIterables([t,n])):Recoil_filterIterable(eP.values(),({key:e})=>!t.has(e)&&!n.has(e))}),_defineProperty(this,"getInfo_UNSTABLE",({key:e})=>(this.checkRefCount_INTERNAL(),eV(this._store,this._store.getState().currentTree,e))),_defineProperty(this,"map",e=>{this.checkRefCount_INTERNAL();let t=new MutableSnapshot(this,eN);return e(t),t}),_defineProperty(this,"asyncMap",async e=>{this.checkRefCount_INTERNAL();let t=new MutableSnapshot(this,eN);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t}),this._store={storeID:ek(),parentStoreID:t,getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{let n=e.graphsByVersion;if(n.has(t))return Recoil_nullthrows(n.get(t));let o=eC();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw err_1("Cannot subscribe to Snapshots")}},this._store.getState().knownAtoms))eL(this._store,n,"get"),ex(this._store,n,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&recoverableViolation_1("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){eG||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach(e=>e()),this._store.getState().nodeCleanupFunctions.clear(),!p("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){p("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}};function cloneStoreState(e,t,n=!1){let o=e.getState(),r=n?ez():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Recoil_mapIterable(o.nodeCleanupFunctions.entries(),([e])=>[e,()=>{}]))}}function freshSnapshot(e){let t=new Snapshot(eW());return null!=e?t.map(e):t}let[eH,eK]=e$((e,t)=>{var n;let o=e.getState(),r="latest"===t?null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree:Recoil_nullthrows(o.previousTree);return new Snapshot(cloneStoreState(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String(null===(n=e.getState().nextTree)||void 0===n?void 0:n.version)+String(e.getState().currentTree.version)+String(null===(o=e.getState().previousTree)||void 0===o?void 0:o.version)});function cloneSnapshot(e,t="latest"){let n=eH(e,t);return n.isRetained()?n:(eK(),eH(e,t))}eF(eK);let MutableSnapshot=class MutableSnapshot extends Snapshot{constructor(e,t){super(cloneStoreState(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0),e.getStoreID()),_defineProperty(this,"_batch",void 0),_defineProperty(this,"set",(e,t)=>{this.checkRefCount_INTERNAL();let n=this.getStore_INTERNAL();this._batch(()=>{ex(n,e.key,1),eD(this.getStore_INTERNAL(),e,t)})}),_defineProperty(this,"reset",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();this._batch(()=>{ex(t,e.key,1),eD(this.getStore_INTERNAL(),e,eI)})}),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",e=>{this.checkRefCount_INTERNAL();let t=this.getStore_INTERNAL();eN(()=>{for(let[n,o]of e.entries())ex(t,n,1),eB(t,new eU(n),o)})}),this._batch=t}};var eq={Snapshot,MutableSnapshot,freshSnapshot,cloneSnapshot},ej=Object.freeze({__proto__:null,Snapshot:eq.Snapshot,MutableSnapshot:eq.MutableSnapshot,freshSnapshot:eq.freshSnapshot,cloneSnapshot:eq.cloneSnapshot}),Recoil_unionSets=function(...e){let t=new Set;for(let n of e)for(let e of n)t.add(e);return t};let{useRef:eZ}=s;var Recoil_useRefInitOnce=function(e){let t=eZ(e);return t.current===e&&"function"==typeof e&&(t.current=e()),t};let{getNextTreeStateVersion:eY,makeEmptyStoreState:eJ}=x,{cleanUpNode:eX,getDownstreamNodes:eQ,initializeNode:e0,setNodeValue:e1,setUnvalidatedAtomValue_DEPRECATED:e2}=j,{graph:e5}=k,{cloneGraph:e4}=k,{getNextStoreID:e8}=U,{createMutableSource:e9,reactMode:e3}=v,{applyAtomValueWrites:e6}=ed,{releaseScheduledRetainablesNow:e7}=ey,{freshSnapshot:te}=ej,{useCallback:tt,useContext:tn,useEffect:to,useMemo:tr,useRef:ta,useState:ti}=s;function notInAContext(){throw err_1("This component must be used inside a <RecoilRoot> component.")}let tl=Object.freeze({storeID:e8(),getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext}),ts=!1;function startNextTreeIfNeeded(e){if(ts)throw err_1("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(null===t.nextTree){p("recoil_memory_managament_2020")&&p("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&e7(e);let n=t.currentTree.version,o=eY();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,e4(Recoil_nullthrows(t.graphsByVersion.get(n))))}}let tu=s.createContext({current:tl}),useStoreRef=()=>tn(tu),tc=s.createContext(null);function notifyComponents(e,t,n){let o=eQ(e,n,n.dirtyAtoms);for(let e of o){let o=t.nodeToComponentSubscriptions.get(e);if(o)for(let[e,[t,r]]of o)r(n)}}function sendEndOfBatchNotifications(e){let t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(let[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(let[t,n]of r)n(e);for(let[n,o]of t.transactionSubscriptions)o(e);(!e3().early||t.suspendedComponentResolvers.size>0)&&(notifyComponents(e,t,n),t.suspendedComponentResolvers.forEach(e=>e()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(e=>e(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function endBatch(e){let t=e.getState();t.commitDepth++;try{let{nextTree:n}=t;if(null==n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,sendEndOfBatchNotifications(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):recoverableViolation_1("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,p("recoil_memory_managament_2020")&&null==n&&e7(e)}finally{t.commitDepth--}}function Batcher({setNotifyBatcherOfChange:e}){let t=useStoreRef(),[,n]=ti([]);return e(()=>n({})),to(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),to(()=>{var e;e=0,(()=>{endBatch(t.current)})()}),null}function initialStoreState_DEPRECATED(e,t){let n=eJ();return t({set:(t,o)=>{let r=n.currentTree,a=e1(e,r,t.key,o),i=new Set(a.keys()),l=r.nonvalidatedAtoms.clone();for(let e of i)l.delete(e);n.currentTree={...r,dirtyAtoms:Recoil_unionSets(r.dirtyAtoms,i),atomValues:e6(r.atomValues,a),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:e=>{e.forEach((e,t)=>{n.currentTree=e2(n.currentTree,t,e)})}}),n}function initialStoreState(e){let t=te(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(e=>e()),n.nodeCleanupFunctions.clear(),n}let td=0;function RecoilRoot_INTERNAL({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;let getGraph=e=>{let t=r.current.graphsByVersion;if(t.has(e))return Recoil_nullthrows(t.get(e));let n=e5();return t.set(e,n),n},subscribeToTransactions=(e,t)=>{if(null==t){let{transactionSubscriptions:t}=l.current.getState(),n=td++;return t.set(n,e),{release:()=>{t.delete(n)}}}{let{nodeTransactionSubscriptions:n}=l.current.getState();n.has(t)||n.set(t,new Map);let o=td++;return Recoil_nullthrows(n.get(t)).set(o,e),{release:()=>{let e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata=e=>{for(let t of(startNextTreeIfNeeded(l.current),Object.keys(e)))Recoil_nullthrows(l.current.getState().nextTree).transactionMetadata[t]=e[t]},replaceState=e=>{let t;startNextTreeIfNeeded(l.current);let n=Recoil_nullthrows(r.current.nextTree);try{ts=!0,t=e(n)}finally{ts=!1}t!==n&&(r.current.nextTree=t,e3().early&&notifyComponents(l.current,r.current,t),Recoil_nullthrows(a.current)())},a=ta(null),i=tt(e=>{a.current=e},[a]),l=Recoil_useRefInitOnce(()=>null!=n?n:{storeID:e8(),getState:()=>r.current,replaceState,getGraph,subscribeToTransactions,addTransactionMetadata});null!=n&&(l.current=n),r=Recoil_useRefInitOnce(()=>null!=e?initialStoreState_DEPRECATED(l.current,e):null!=t?initialStoreState(t):eJ());let u=tr(()=>null==e9?void 0:e9(r,()=>r.current.currentTree.version),[r]);return to(()=>{let e=l.current;for(let t of new Set(e.getState().knownAtoms))e0(e,t,"get");return()=>{for(let t of e.getState().knownAtoms)eX(e,t)}},[l]),s.createElement(tu.Provider,{value:l},s.createElement(tc.Provider,{value:u},s.createElement(Batcher,{setNotifyBatcherOfChange:i}),o))}function useRecoilStoreID(){return useStoreRef().current.storeID}var tf={RecoilRoot:function(e){let{override:t,...n}=e,o=useStoreRef();return!1===t&&o.current!==tl?e.children:s.createElement(RecoilRoot_INTERNAL,n)},useStoreRef,useRecoilMutableSource:function(){let e=tn(tc);return null==e&&expectationViolation_1("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID,notifyComponents_FOR_TESTING:notifyComponents,sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications},Recoil_shallowArrayEqual=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};let{useEffect:th,useRef:tp}=s;var Recoil_usePrevious=function(e){let t=tp();return th(()=>{t.current=e}),t.current};let{useStoreRef:t_}=tf,{SUSPENSE_TIMEOUT_MS:tm}=ey,{updateRetainCount:ty}=ey,{RetentionZone:tS}=F,{useEffect:tv,useRef:tR}=s,{isSSR:tg}=eE;function useRetain_ACTUAL(e){let t=Array.isArray(e)?e:[e],n=t.map(e=>e instanceof tS?e:e.key),o=t_();tv(()=>{if(!p("recoil_memory_managament_2020"))return;let e=o.current;if(r.current&&!tg)window.clearTimeout(r.current),r.current=null;else for(let t of n)ty(e,t,1);return()=>{for(let t of n)ty(e,t,-1)}},[o,...n]);let r=tR(),a=Recoil_usePrevious(n);if(!tg&&(void 0===a||!Recoil_shallowArrayEqual(a,n))){let e=o.current;for(let t of n)ty(e,t,1);if(a)for(let t of a)ty(e,t,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{for(let t of(r.current=null,n))ty(e,t,-1)},tm)}}var Recoil_useRetain=function(e){if(p("recoil_memory_managament_2020"))return useRetain_ACTUAL(e)},Recoil_useComponentName=function(){return"<component name not available>"};let{batchUpdates:tb}=eT,{DEFAULT_VALUE:tT}=N,{currentRendererSupportsUseSyncExternalStore:tw,reactMode:tA,useMutableSource:tE,useSyncExternalStore:tN}=v,{useRecoilMutableSource:tL,useStoreRef:tV}=tf,{isRecoilValue:tC}=g,{AbstractRecoilValue:tk,getRecoilValueAsLoadable:tI,setRecoilValue:tP,setUnvalidatedRecoilValue:tM,subscribeToRecoilValue:tU}=ed,{useCallback:tO,useEffect:tD,useMemo:tB,useRef:tx,useState:tF}=s,{setByAddingToSet:tz}=z,{isSSR:tW}=eE;function handleLoadable(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){let t=new Promise(t=>{let o=n.current.getState().suspendedComponentResolvers;o.add(t),tW&&Recoil_isPromise(e.contents)&&e.contents.finally(()=>{o.delete(t)})});throw t}if("hasError"===e.state)throw e.contents;throw err_1(`Invalid value of loadable atom "${t.key}"`)}function useRecoilInterface_DEPRECATED(){let e=Recoil_useComponentName(),t=tV(),[,n]=tF([]),o=tx(new Set);o.current=new Set;let r=tx(new Set),a=tx(new Map),i=tO(e=>{let t=a.current.get(e);t&&(t.release(),a.current.delete(e))},[a]),l=tO((e,t)=>{a.current.has(t)&&n([])},[]);return tD(()=>{let n=t.current;Recoil_differenceSets(o.current,r.current).forEach(t=>{if(a.current.has(t)){expectationViolation_1(`Double subscription to RecoilValue "${t}"`);return}let o=tU(n,new tk(t),e=>l(e,t),e);a.current.set(t,o);let r=n.getState();r.nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(n.getState(),t)}):l(n.getState(),t)}),Recoil_differenceSets(r.current,o.current).forEach(e=>{i(e)}),r.current=o.current}),tD(()=>{let n=a.current;return Recoil_differenceSets(o.current,new Set(n.keys())).forEach(o=>{let r=tU(t.current,new tk(o),e=>l(e,o),e);n.set(o,r)}),()=>n.forEach((e,t)=>i(t))},[e,t,i,l]),tB(()=>{function useSetRecoilState(e){return n=>{tP(t.current,e,n)}}function useRecoilValueLoadable(e){var n;o.current.has(e.key)||(o.current=tz(o.current,e.key));let r=t.current.getState();return tI(t.current,e,tA().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree)}function useRecoilValue(e){let n=useRecoilValueLoadable(e);return handleLoadable(n,e,t)}function useRecoilState(e){return[useRecoilValue(e),useSetRecoilState(e)]}function useRecoilStateLoadable(e){return[useRecoilValueLoadable(e),useSetRecoilState(e)]}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:useRecoilState,getRecoilStateLoadable:useRecoilStateLoadable,getSetRecoilState:useSetRecoilState,getResetRecoilState:function(e){return()=>tP(t.current,e,tT)}}},[o,t])}function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(e){let t=tV(),n=Recoil_useComponentName(),o=tO(()=>{var n;let o=t.current,r=o.getState(),a=tA().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree,i=tI(o,e,a);return{loadable:i,key:e.key}},[t,e]),r=tO(e=>{let t;return()=>{var n,o;let r=e();return null!==(n=t)&&void 0!==n&&n.loadable.is(r.loadable)&&(null===(o=t)||void 0===o?void 0:o.key)===r.key?t:(t=r,r)}},[]),a=tB(()=>r(o),[o,r]),i=tO(o=>{let r=t.current,a=tU(r,e,o,n);return a.release},[t,e,n]);return tN(i,a,a).loadable}function useRecoilValueLoadable_MUTABLE_SOURCE(e){let t=tV(),n=tO(()=>{var n;let o=t.current,r=o.getState(),a=tA().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return tI(o,e,a)},[t,e]),o=tO(()=>n(),[n]),r=Recoil_useComponentName(),a=tO((o,a)=>{let i=t.current,l=tU(i,e,()=>{if(!p("recoil_suppress_rerender_in_callback"))return a();let e=n();s.current.is(e)||a(),s.current=e},r);return l.release},[t,e,r,n]),i=tL();if(null==i)throw err_1("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=tE(i,o,a),s=tx(l);return tD(()=>{s.current=l}),l}function useRecoilValueLoadable_TRANSITION_SUPPORT(e){let t=tV(),n=Recoil_useComponentName(),o=tO(()=>{var n;let o=t.current,r=o.getState(),a=tA().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return tI(o,e,a)},[t,e]),r=tO(()=>({loadable:o(),key:e.key}),[o,e.key]),a=tO(e=>{let t=r();return e.loadable.is(t.loadable)&&e.key===t.key?e:t},[r]);tD(()=>{let o=tU(t.current,e,e=>{l(a)},n);return l(a),o.release},[n,e,t,a]);let[i,l]=tF(r);return i.key!==e.key?r().loadable:i.loadable}function useRecoilValueLoadable_LEGACY(e){let t=tV(),[,n]=tF([]),o=Recoil_useComponentName(),r=tO(()=>{var n;let o=t.current,r=o.getState(),a=tA().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return tI(o,e,a)},[t,e]),a=r(),i=tx(a);return tD(()=>{i.current=a}),tD(()=>{let a=t.current,l=a.getState(),s=tU(a,e,e=>{var t;if(!p("recoil_suppress_rerender_in_callback"))return n([]);let o=r();null!==(t=i.current)&&void 0!==t&&t.is(o)||n(o),i.current=o},o);if(l.nextTree)a.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var u;if(!p("recoil_suppress_rerender_in_callback"))return n([]);let e=r();null!==(u=i.current)&&void 0!==u&&u.is(e)||n(e),i.current=e}return s.release},[o,r,e,t]),a}function useRecoilValueLoadable(e){return p("recoil_memory_managament_2020")&&Recoil_useRetain(e),({TRANSITION_SUPPORT:useRecoilValueLoadable_TRANSITION_SUPPORT,SYNC_EXTERNAL_STORE:tw()?useRecoilValueLoadable_SYNC_EXTERNAL_STORE:useRecoilValueLoadable_TRANSITION_SUPPORT,MUTABLE_SOURCE:useRecoilValueLoadable_MUTABLE_SOURCE,LEGACY:useRecoilValueLoadable_LEGACY})[tA().mode](e)}function useRecoilValue(e){let t=tV(),n=useRecoilValueLoadable(e);return handleLoadable(n,e,t)}function useSetRecoilState(e){let t=tV();return tO(n=>{tP(t.current,e,n)},[t,e])}function useResetRecoilState(e){let t=tV();return tO(()=>{tP(t.current,e,tT)},[t,e])}function useRecoilState(e){return[useRecoilValue(e),useSetRecoilState(e)]}function useRecoilStateLoadable(e){return[useRecoilValueLoadable(e),useSetRecoilState(e)]}function useSetUnvalidatedAtomValues(){let e=tV();return(t,n={})=>{tb(()=>{e.current.addTransactionMetadata(n),t.forEach((t,n)=>tM(e.current,new tk(n),t))})}}function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(e){return p("recoil_memory_managament_2020")&&Recoil_useRetain(e),useRecoilValueLoadable_TRANSITION_SUPPORT(e)}function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(e){let t=tV(),n=useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(e);return handleLoadable(n,e,t)}function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(e){return[useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(e),useSetRecoilState(e)]}var Recoil_filterMap=function(e,t){let n=new Map;for(let[o,r]of e)t(r,o)&&n.set(o,r);return n},Recoil_filterSet=function(e,t){let n=new Set;for(let o of e)t(o)&&n.add(o);return n},Recoil_mergeMaps=function(...e){let t=new Map;for(let n=0;n<e.length;n++){let o;let r=e[n].keys();for(;!(o=r.next()).done;)t.set(o.value,e[n].get(o.value))}return t};let{batchUpdates:tG}=eT,{DEFAULT_VALUE:t$,getNode:tH,nodes:tK}=N,{useStoreRef:tq}=tf,{AbstractRecoilValue:tj,setRecoilValueLoadable:tZ}=ed,{SUSPENSE_TIMEOUT_MS:tY}=ey,{cloneSnapshot:tJ}=ej,{useCallback:tX,useEffect:tQ,useRef:t0,useState:t1}=s,{isSSR:t2}=eE;function useTransactionSubscription(e){let t=tq();tQ(()=>{let n=t.current.subscribeToTransactions(e);return n.release},[e,t])}function externallyVisibleAtomValuesInState(e){let t=e.atomValues.toMap(),n=Recoil_mapMap(Recoil_filterMap(t,(e,t)=>{let n=tH(t),o=n.persistence_UNSTABLE;return null!=o&&"none"!==o.type&&"hasValue"===e.state}),e=>e.contents);return Recoil_mergeMaps(e.nonvalidatedAtoms.toMap(),n)}function gotoSnapshot(e,t){var n;let o=e.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;tG(()=>{let n=new Set;for(let e of[r.atomValues.keys(),a.atomValues.keys()])for(let t of e){var o,i;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(i=a.atomValues.get(t))||void 0===i?void 0:i.contents)&&tH(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach(t=>{tZ(e,new tj(t),a.atomValues.has(t)?Recoil_nullthrows(a.atomValues.get(t)):t$)}),e.replaceState(e=>({...e,stateID:t.getID()}))})}function useGotoRecoilSnapshot(){let e=tq();return tX(t=>gotoSnapshot(e.current,t),[e])}var t5={useRecoilSnapshot:function(){let e=tq(),[t,n]=t1(()=>tJ(e.current)),o=Recoil_usePrevious(t),r=t0(),a=t0();if(useTransactionSubscription(tX(e=>n(tJ(e)),[])),tQ(()=>{let e=t.retain();if(r.current&&!t2){var n;window.clearTimeout(r.current),r.current=null,null===(n=a.current)||void 0===n||n.call(a),a.current=null}return()=>{window.setTimeout(e,10)}},[t]),o!==t&&!t2){if(r.current){var i;window.clearTimeout(r.current),r.current=null,null===(i=a.current)||void 0===i||i.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var e;r.current=null,null===(e=a.current)||void 0===e||e.call(a),a.current=null},tY)}return t},gotoSnapshot,useGotoRecoilSnapshot,useRecoilTransactionObserver:function(e){useTransactionSubscription(tX(t=>{let n=tJ(t,"latest"),o=tJ(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))},useTransactionObservation_DEPRECATED:function(e){useTransactionSubscription(tX(t=>{let n=t.getState().previousTree,o=t.getState().currentTree;n||(recoverableViolation_1("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);let r=externallyVisibleAtomValuesInState(o),a=externallyVisibleAtomValuesInState(n),i=Recoil_mapMap(tK,e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}}),l=Recoil_filterSet(o.dirtyAtoms,e=>r.has(e)||a.has(e));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};let{peekNodeInfo:t4}=j,{useStoreRef:t8}=tf,{reactMode:t9}=v,{RecoilRoot:t3,useStoreRef:t6}=tf,{useMemo:t7}=s,{loadableWithValue:ne}=f,{initializeNode:nt}=j,{DEFAULT_VALUE:nn,getNode:no}=N,{copyTreeState:nr,getRecoilValueAsLoadable:na,invalidateDownstreams:ni,writeLoadableToTreeState:nl}=ed;function isAtom(e){return"atom"===no(e.key).nodeType}let TransactionInterfaceImpl=class TransactionInterfaceImpl{constructor(e,t){_defineProperty(this,"_store",void 0),_defineProperty(this,"_treeState",void 0),_defineProperty(this,"_changes",void 0),_defineProperty(this,"get",e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!isAtom(e))throw err_1("Reading selectors within atomicUpdate is not supported");let t=na(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;if("hasError"===t.state)throw t.contents;throw err_1(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)}),_defineProperty(this,"set",(e,t)=>{if(!isAtom(e))throw err_1("Setting selectors within atomicUpdate is not supported");if("function"==typeof t){let n=this.get(e);this._changes.set(e.key,t(n))}else nt(this._store,e.key,"set"),this._changes.set(e.key,t)}),_defineProperty(this,"reset",e=>{this.set(e,nn)}),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;let e=nr(this._treeState);for(let[t,n]of this._changes)nl(e,t,ne(n));return ni(this._store,e),e}};var ns=Object.freeze({__proto__:null,atomicUpdater:function(e){return t=>{e.replaceState(n=>{let o=new TransactionInterfaceImpl(e,n);return t(o),o.newTreeState_INTERNAL()})}}}),invariant_1=function(e,t){if(!e)throw Error(t)};let{atomicUpdater:nu}=ns,{batchUpdates:nc}=eT,{DEFAULT_VALUE:nd}=N,{useStoreRef:nf}=tf,{refreshRecoilValue:nh,setRecoilValue:np}=ed,{cloneSnapshot:n_}=ej,{gotoSnapshot:nm}=t5,{useCallback:ny}=s;let Sentinel=class Sentinel{};let nS=new Sentinel;function recoilCallback(e,t,n,o){let r,a=nS;if(nc(()=>{let i="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof t)throw err_1(i);let l=Recoil_lazyProxy({...null!=o?o:{},set:(t,n)=>np(e,t,n),reset:t=>np(e,t,nd),refresh:t=>nh(e,t),gotoSnapshot:t=>nm(e,t),transact_UNSTABLE:t=>nu(e)(t)},{snapshot:()=>{let t=n_(e);return r=t.retain(),t}}),s=t(l);if("function"!=typeof s)throw err_1(i);a=s(...n)}),a instanceof Sentinel&&invariant_1(!1),Recoil_isPromise(a))a=a.finally(()=>{var e;null===(e=r)||void 0===e||e()});else{var i;null===(i=r)||void 0===i||i()}return a}function useRecoilCallback(e,t){let n=nf();return ny((...t)=>recoilCallback(n.current,e,t),null!=t?[...t,n]:void 0)}var nv={recoilCallback,useRecoilCallback};let{useStoreRef:nR}=tf,{refreshRecoilValue:ng}=ed,{useCallback:nb}=s,{atomicUpdater:nT}=ns,{useStoreRef:nw}=tf,{useMemo:nA}=s;let WrappedValue=class WrappedValue{constructor(e){_defineProperty(this,"value",void 0),this.value=e}};var nE=Object.freeze({__proto__:null,WrappedValue:{WrappedValue}.WrappedValue});let{isFastRefreshEnabled:nN}=v;let ChangedPathError=class ChangedPathError extends Error{};let TreeCache=class TreeCache{constructor(e){var t,n,o;_defineProperty(this,"_name",void 0),_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._name=null==e?void 0:e.name,this._numLeafs=0,this._root=null,this._onHit=null!==(t=null==e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null==e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null==e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){if(null==this._root)return;let n=this._root;for(;n;){if(null==t||t.onNodeVisit(n),"leaf"===n.type)return this._onHit(n),n;let o=this._mapNodeValue(e(n.nodeKey));n=n.branches.get(o)}}set(e,t,n){let addLeaf=()=>{var o,r,a,i,l,s,u;let c,d;for(let[t,o]of e){let e=this._root;if((null==e?void 0:e.type)==="leaf")throw this.invalidCacheError();let r=c;if("branch"!==(c=null!==(l=c=r?r.branches.get(d):e)&&void 0!==l?l:{type:"branch",nodeKey:t,parent:r,branches:new Map,branchKey:d}).type||c.nodeKey!==t)throw this.invalidCacheError();null==r||r.branches.set(d,c),null==n||null===(s=n.onNodeVisit)||void 0===s||s.call(n,c),d=this._mapNodeValue(o),this._root=null!==(u=this._root)&&void 0!==u?u:c}let f=c?null===(o=c)||void 0===o?void 0:o.branches.get(d):this._root;if(null!=f&&("leaf"!==f.type||f.branchKey!==d))throw this.invalidCacheError();let h={type:"leaf",value:t,parent:c,branchKey:d};null===(r=c)||void 0===r||r.branches.set(d,h),this._root=null!==(a=this._root)&&void 0!==a?a:h,this._numLeafs++,this._onSet(h),null==n||null===(i=n.onNodeVisit)||void 0===i||i.call(n,h)};try{addLeaf()}catch(e){if(e instanceof ChangedPathError)this.clear(),addLeaf();else throw e}}delete(e){let t=this.root();if(!t)return!1;if(e===t)return this._root=null,this._numLeafs=0,!0;let n=e.parent,o=e.branchKey;for(;n;){var r;if(n.branches.delete(o),n===t)return 0===n.branches.size?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(n.branches.size>0)break;o=null===(r=n)||void 0===r?void 0:r.branchKey,n=n.parent}for(;n!==t;n=n.parent)if(null==n)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){let e=nN()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw recoverableViolation_1(e+(null!=this._name?` - ${this._name}`:"")),new ChangedPathError}};var nL=Object.freeze({__proto__:null,TreeCache:{TreeCache}.TreeCache});let LRUCache=class LRUCache{constructor(e){var t;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){let t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){let n=this._keyMapper(e),o=this._map.get(n);o&&this.delete(e);let r=this.head(),a={key:e,right:r,left:null,value:t};r?r.left=a:this._tail=a,this._map.set(n,a),this._head=a,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let e=this.tail();e&&this.delete(e.key)}delete(e){let t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;let n=Recoil_nullthrows(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}};var nV=Object.freeze({__proto__:null,LRUCache:{LRUCache}.LRUCache});let{LRUCache:nC}=nV,{TreeCache:nk}=nL;var Recoil_treeCacheLRU=function({name:e,maxSize:t,mapNodeValue:n=e=>e}){let o=new nC({maxSize:t}),r=new nk({name:e,mapNodeValue:n,onHit:e=>{o.set(e,!0)},onSet:e=>{let n=o.tail();o.set(e,!0),n&&r.size()>t&&r.delete(n.key)}});return r};function stringify(e,t,n){if("string"==typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((null==t?void 0:t.allowFunctions)!==!0)throw err_1("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";if("object"!=typeof e){var o;return null!==(o=JSON.stringify(e))&&void 0!==o?o:""}if(Recoil_isPromise(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((e,n)=>stringify(e,t,n.toString()))}]`;if("function"==typeof e.toJSON)return stringify(e.toJSON(n),t,n);if(e instanceof Map){let o={};for(let[n,r]of e)o["string"==typeof n?n:stringify(n,t)]=r;return stringify(o,t,n)}return e instanceof Set?stringify(Array.from(e).sort((e,n)=>stringify(e,t).localeCompare(stringify(n,t))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"==typeof e[Symbol.iterator]?stringify(Array.from(e),t,n):`{${Object.keys(e).filter(t=>void 0!==e[t]).sort().map(n=>`${stringify(n,t)}:${stringify(e[n],t,n)}`).join(",")}}`}var Recoil_stableStringify=function(e,t={allowFunctions:!1}){return stringify(e,t)};let{TreeCache:nI}=nL,nP={equality:"reference",eviction:"keep-all",maxSize:1/0};function getValueMapper(e){switch(e){case"reference":return e=>e;case"value":return e=>Recoil_stableStringify(e)}throw err_1(`Unrecognized equality policy ${e}`)}function getTreeCache(e,t,n,o){switch(e){case"keep-all":return new nI({name:o,mapNodeValue:n});case"lru":return Recoil_treeCacheLRU({name:o,maxSize:Recoil_nullthrows(t),mapNodeValue:n});case"most-recent":return Recoil_treeCacheLRU({name:o,maxSize:1,mapNodeValue:n})}throw err_1(`Unrecognized eviction policy ${e}`)}var Recoil_treeCacheFromPolicy=function({equality:e=nP.equality,eviction:t=nP.eviction,maxSize:n=nP.maxSize}=nP,o){let r=getValueMapper(e);return getTreeCache(t,n,r,o)};let{isReactNative:nM,isWindow:nU}=eE;function startPerfBlock(e){return()=>null}let{isLoadable:nO,loadableWithError:nD,loadableWithPromise:nB,loadableWithValue:nx}=f,{WrappedValue:nF}=nE,{getNodeLoadable:nz,peekNodeLoadable:nW,setNodeValue:nG}=j,{saveDepsToStore:n$}=k,{DEFAULT_VALUE:nH,getConfigDeletionHandler:nK,getNode:nq,registerNode:nj}=N,{isRecoilValue:nZ}=g,{markRecoilValueModified:nY}=ed,{retainedByOptionWithDefault:nJ}=ey,{recoilCallback:nX}=nv,{startPerfBlock:nQ}={startPerfBlock};let Canceled=class Canceled{};let n0=new Canceled,n1=[],n2=new Map,n5=(o=0,()=>o++);function selector(e){let t=null,{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=null!=e.set?e.set:void 0,i=new Set,l=Recoil_treeCacheFromPolicy(null!=r?r:{equality:"reference",eviction:"keep-all"},n),s=nJ(e.retainedBy_UNSTABLE),u=new Map,c=0;function selectorIsLive(){return!p("recoil_memory_managament_2020")||c>0}function selectorInit(e){return e.getState().knownSelectors.add(n),c++,()=>{c--}}function selectorShouldDeleteConfigOnRelease(){return void 0!==nK(n)&&!selectorIsLive()}function notifyStoresOfResolvedAsync(e,t){isLatestExecution(e,t)&&clearExecutionInfo(e),notifyWaitingStores(t,!0)}function notifyStoresOfNewAsyncDep(e,t){if(isLatestExecution(e,t)){let n=Recoil_nullthrows(getExecutionInfo(e));n.stateVersions.clear(),notifyWaitingStores(t,!1)}}function notifyWaitingStores(e,n){let o=n2.get(e);if(null!=o){for(let e of o)nY(e,Recoil_nullthrows(t));n&&n2.delete(e)}}function markStoreWaitingForResolvedAsync(e,t){let n=n2.get(t);null==n&&n2.set(t,n=new Set),n.add(e)}function wrapResultPromise(e,t,n,o,r,a){return t.then(t=>{if(!selectorIsLive())throw clearExecutionInfo(e),n0;let a=nx(t);return setCache(n,a,o),notifyStoresOfResolvedAsync(e,r),t}).catch(t=>{if(!selectorIsLive())throw clearExecutionInfo(e),n0;if(Recoil_isPromise(t))return wrapPendingDependencyPromise(e,t,n,o,r,a);let i=nD(t);throw setCache(n,i,o),notifyStoresOfResolvedAsync(e,r),t})}function wrapPendingDependencyPromise(e,t,n,o,r,a){return t.then(o=>{if(!selectorIsLive())throw clearExecutionInfo(e),n0;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,nx(o)):e.getState().knownSelectors.forEach(e=>{n.atomValues.delete(e)});let i=getLoadableFromCacheAndUpdateDeps(e,n);if(i&&"loading"!==i.state){if((isLatestExecution(e,r)||null==getExecutionInfo(e))&&notifyStoresOfResolvedAsync(e,r),"hasValue"===i.state)return i.contents;throw i.contents}if(!isLatestExecution(e,r)){let t=getInProgressExecutionInfo(e,n);if(null!=t)return t.loadingLoadable.contents}let[l,s]=evaluateSelectorGetter(e,n,r);if("loading"!==l.state&&(setCache(n,l,s),notifyStoresOfResolvedAsync(e,r)),"hasError"===l.state)throw l.contents;return l.contents}).catch(t=>{if(t instanceof Canceled)throw n0;if(!selectorIsLive())throw clearExecutionInfo(e),n0;let a=nD(t);throw setCache(n,a,o),notifyStoresOfResolvedAsync(e,r),t})}function updateDeps(e,t,o,r){var a,l,s,u,c,d,f;for(let h of((isLatestExecution(e,r)||t.version===(null===(a=e.getState())||void 0===a?void 0:null===(l=a.currentTree)||void 0===l?void 0:l.version)||t.version===(null===(s=e.getState())||void 0===s?void 0:null===(u=s.nextTree)||void 0===u?void 0:u.version))&&n$(n,o,e,null!==(c=null===(d=e.getState())||void 0===d?void 0:null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==c?c:e.getState().currentTree.version),o))i.add(h)}function evaluateSelectorGetter(e,r,a){let i,l;let s=nQ(n),u=!0,c=!0,finishEvaluation=()=>{s(),c=!1},d=!1,f={loadingDepKey:null,loadingDepPromise:null},h=new Map;function getRecoilValue({key:t}){let n=nz(e,r,t);switch(h.set(t,n),u||(updateDeps(e,r,new Set(h.keys()),a),notifyStoresOfNewAsyncDep(e,a)),n.state){case"hasValue":return n.contents;case"hasError":throw n.contents;case"loading":throw f.loadingDepKey=t,f.loadingDepPromise=n.contents,n.contents}throw err_1("Invalid Loadable state")}try{i=o({get:getRecoilValue,getCallback:n=>(...o)=>{if(c)throw err_1("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null!=t||invariant_1(!1),nX(e,n,o,{node:t})}}),i=nZ(i)?getRecoilValue(i):i,nO(i)&&("hasError"===i.state&&(d=!0),i=i.contents),Recoil_isPromise(i)?i=wrapResultPromise(e,i,r,h,a,f).finally(finishEvaluation):finishEvaluation(),i=i instanceof nF?i.value:i}catch(t){Recoil_isPromise(i=t)?i=wrapPendingDependencyPromise(e,i,r,h,a,f).finally(finishEvaluation):(d=!0,finishEvaluation())}return l=d?nD(i):Recoil_isPromise(i)?nB(i):nx(i),u=!1,updateExecutionInfoDepValues(e,a,h),updateDeps(e,r,new Set(h.keys()),a),[l,h]}function getLoadableFromCacheAndUpdateDeps(e,t){let o=t.atomValues.get(n);if(null!=o)return o;let r=new Set;try{o=l.get(n=>("string"!=typeof n&&invariant_1(!1),nz(e,t,n).contents),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&r.add(e.nodeKey)}})}catch(e){throw err_1(`Problem with cache lookup for selector "${n}": ${e.message}`)}if(o){var a;t.atomValues.set(n,o),updateDeps(e,t,r,null===(a=getExecutionInfo(e))||void 0===a?void 0:a.executionID)}return o}function getSelectorLoadableAndUpdateDeps(e,t){let n=getLoadableFromCacheAndUpdateDeps(e,t);if(null!=n)return clearExecutionInfo(e),n;let o=getInProgressExecutionInfo(e,t);if(null!=o){var r;return(null===(r=o.loadingLoadable)||void 0===r?void 0:r.state)==="loading"&&markStoreWaitingForResolvedAsync(e,o.executionID),o.loadingLoadable}let a=n5(),[i,l]=evaluateSelectorGetter(e,t,a);return"loading"===i.state?(setExecutionInfo(e,a,i,l,t),markStoreWaitingForResolvedAsync(e,a)):(clearExecutionInfo(e),setCache(t,i,l)),i}function getInProgressExecutionInfo(e,t){let n=Recoil_concatIterables([u.has(e)?[Recoil_nullthrows(u.get(e))]:[],Recoil_mapIterable(Recoil_filterIterable(u,([t])=>t!==e),([,e])=>e)]);function anyDepChanged(n){for(let[o,r]of n)if(!nz(e,t,o).is(r))return!0;return!1}for(let e of n){if(e.stateVersions.get(t.version)||!anyDepChanged(e.depValuesDiscoveredSoFarDuringAsyncWork))return e.stateVersions.set(t.version,!0),e;e.stateVersions.set(t.version,!1)}}function getExecutionInfo(e){return u.get(e)}function setExecutionInfo(e,t,n,o,r){u.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:o,executionID:t,loadingLoadable:n,stateVersions:new Map([[r.version,!0]])})}function updateExecutionInfoDepValues(e,t,n){if(isLatestExecution(e,t)){let t=getExecutionInfo(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=n)}}function clearExecutionInfo(e){u.delete(e)}function isLatestExecution(e,t){var n;return t===(null===(n=getExecutionInfo(e))||void 0===n?void 0:n.executionID)}function depValuesToDepRoute(e){return Array.from(e.entries()).map(([e,t])=>[e,t.contents])}function setCache(e,t,o){e.atomValues.set(n,t);try{l.set(depValuesToDepRoute(o),t)}catch(e){throw err_1(`Problem with setting cache for selector "${n}": ${e.message}`)}}function detectCircularDependencies(e){if(n1.includes(n)){let e=`Recoil selector has circular dependencies: ${n1.slice(n1.indexOf(n)).join(" → ")}`;return nD(err_1(e))}n1.push(n);try{return e()}finally{n1.pop()}}function selectorPeek(e,t){let o=t.atomValues.get(n);return null!=o?o:l.get(n=>{var o;return"string"!=typeof n&&invariant_1(!1),null===(o=nW(e,t,n))||void 0===o?void 0:o.contents})}function selectorGet(e,t){return detectCircularDependencies(()=>getSelectorLoadableAndUpdateDeps(e,t))}function invalidateSelector(e){e.atomValues.delete(n)}function clearSelectorCache(e,n){for(let r of(null!=t||invariant_1(!1),i)){var o;let t=nq(r);null===(o=t.clearCache)||void 0===o||o.call(t,e,n)}i.clear(),invalidateSelector(n),l.clear(),nY(e,t)}return t=null!=a?nj({key:n,nodeType:"selector",peek:selectorPeek,get:selectorGet,set:(e,t,o)=>{let r=!1,i=new Map;function getRecoilValue({key:o}){if(r)throw err_1("Recoil: Async selector sets are not currently supported.");let a=nz(e,t,o);if("hasValue"===a.state)return a.contents;if("loading"===a.state){let e=`Getting value of asynchronous atom or selector "${o}" in a pending state while setting selector "${n}" is not yet supported.`;throw recoverableViolation_1(e),err_1(e)}throw a.contents}function setRecoilState(n,o){if(r){let e="Recoil: Async selector sets are not currently supported.";throw recoverableViolation_1(e),err_1(e)}let a="function"==typeof o?o(getRecoilValue(n)):o,l=nG(e,t,n.key,a);l.forEach((e,t)=>i.set(t,e))}function resetRecoilState(e){setRecoilState(e,nH)}let l=a({set:setRecoilState,get:getRecoilValue,reset:resetRecoilState},o);if(void 0!==l)throw err_1(Recoil_isPromise(l)?"Recoil: Async selector sets are not currently supported.":"Recoil: selector set should be a void function.");return r=!0,i},init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s}):nj({key:n,nodeType:"selector",peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:s})}selector.value=e=>new nF(e);var n4=selector;let{isLoadable:n8,loadableWithError:n9,loadableWithPromise:n3,loadableWithValue:n6}=f,{WrappedValue:n7}=nE,{peekNodeInfo:oe}=j,{DEFAULT_VALUE:ot,DefaultValue:on,getConfigDeletionHandler:oo,registerNode:or,setConfigDeletionHandler:oa}=N,{isRecoilValue:oi}=g,{getRecoilValueAsLoadable:ol,markRecoilValueModified:os,setRecoilValue:ou,setRecoilValueLoadable:oc}=ed,{retainedByOptionWithDefault:od}=ey,unwrap=e=>e instanceof n7?e.value:e;function baseAtom(e){var t;let n;let{key:o,persistence_UNSTABLE:r}=e,a=od(e.retainedBy_UNSTABLE),i=0;function unwrapPromise(e){return n3(e.then(e=>(l=n6(e),e)).catch(e=>{throw l=n9(e),e}))}let l=Recoil_isPromise(e.default)?unwrapPromise(e.default):n8(e.default)?"loading"===e.default.state?unwrapPromise(e.default.contents):e.default:n6(unwrap(e.default));l.contents;let s=new Map;function wrapPendingPromise(e,t){let n=t.then(t=>{var r,a;let i=null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree;return(null===(a=i.atomValues.get(o))||void 0===a?void 0:a.contents)===n&&ou(e,u,t),t}).catch(t=>{var r,a;let i=null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree;throw(null===(a=i.atomValues.get(o))||void 0===a?void 0:a.contents)===n&&oc(e,u,n9(t)),t});return n}function initAtom(t,n,r){var a,c,d;i++,t.getState().knownAtoms.add(o),"loading"===l.state&&l.contents.finally(()=>{var e;let n=null!==(e=t.getState().nextTree)&&void 0!==e?e:t.getState().currentTree;n.atomValues.has(o)||os(t,u)});let f=null!==(a=e.effects)&&void 0!==a?a:e.effects_UNSTABLE;if(null!=f){let e=ot,a=!0,i=!1,h=null;function getLoadable(r){if(a&&r.key===o){let o=e;return o instanceof on?peekAtom(t,n):Recoil_isPromise(o)?n3(o.then(e=>e instanceof on?l.toPromise():e)):n6(o)}return ol(t,r)}function getPromise(e){return getLoadable(e).toPromise()}function getInfo_UNSTABLE(n){var r;let i=oe(t,null!==(r=t.getState().nextTree)&&void 0!==r?r:t.getState().currentTree,n.key);return!a||n.key!==o||e instanceof on?i:{...i,isSet:!0,loadable:getLoadable(n)}}let setSelf=n=>o=>{if(a){let t=getLoadable(u),r="hasValue"===t.state?t.contents:ot;Recoil_isPromise(e="function"==typeof o?o(r):o)&&(e=e.then(e=>(h={effect:n,value:e},e)))}else{if(Recoil_isPromise(o))throw err_1("Setting atoms to async values is not implemented.");"function"!=typeof o&&(h={effect:n,value:unwrap(o)}),ou(t,u,"function"==typeof o?e=>{let t=unwrap(o(e));return h={effect:n,value:t},t}:unwrap(o))}},resetSelf=e=>()=>setSelf(e)(ot),onSet=e=>n=>{var r;let{release:a}=t.subscribeToTransactions(t=>{var r,a,i,s,u;let{currentTree:c,previousTree:d}=t.getState();d||(recoverableViolation_1("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),d=c);let f=null!==(r=c.atomValues.get(o))&&void 0!==r?r:l;if("hasValue"===f.state){let t=f.contents,r=null!==(a=d.atomValues.get(o))&&void 0!==a?a:l,p="hasValue"===r.state?r.contents:ot;(null===(i=h)||void 0===i?void 0:i.effect)!==e||(null===(s=h)||void 0===s?void 0:s.value)!==t?n(t,p,!c.atomValues.has(o)):(null===(u=h)||void 0===u?void 0:u.effect)===e&&(h=null)}},o);s.set(t,[...null!==(r=s.get(t))&&void 0!==r?r:[],a])};for(let n of f)try{let e=n({node:u,storeID:t.storeID,parentStoreID_UNSTABLE:t.parentStoreID,trigger:r,setSelf:setSelf(n),resetSelf:resetSelf(n),onSet:onSet(n),getPromise,getLoadable,getInfo_UNSTABLE});null!=e&&s.set(t,[...null!==(c=s.get(t))&&void 0!==c?c:[],e])}catch(t){e=t,i=!0}if(a=!1,!(e instanceof on)){let r=i?n9(e):Recoil_isPromise(e)?n3(wrapPendingPromise(t,e)):n6(unwrap(e));r.contents,n.atomValues.set(o,r),null===(d=t.getState().nextTree)||void 0===d||d.atomValues.set(o,r)}}return()=>{var e;i--,null===(e=s.get(t))||void 0===e||e.forEach(e=>e()),s.delete(t)}}function peekAtom(e,t){var r,a;return null!==(r=null!==(a=t.atomValues.get(o))&&void 0!==a?a:n)&&void 0!==r?r:l}function getAtom(e,t){if(t.atomValues.has(o))return Recoil_nullthrows(t.atomValues.get(o));if(!t.nonvalidatedAtoms.has(o))return l;{if(null!=n)return n;if(null==r)return expectationViolation_1(`Tried to restore a persisted value for atom ${o} but it has no persistence settings.`),l;let e=t.nonvalidatedAtoms.get(o),a=r.validator(e,ot),i=a instanceof on?l:n6(a);return n=i}}function invalidateAtom(){n=void 0}function setAtom(e,t,r){if(t.atomValues.has(o)){let e=Recoil_nullthrows(t.atomValues.get(o));if("hasValue"===e.state&&r===e.contents)return new Map}else if(!t.nonvalidatedAtoms.has(o)&&r instanceof on)return new Map;return n=void 0,new Map().set(o,n6(r))}function shouldDeleteConfigOnReleaseAtom(){return void 0!==oo(o)&&i<=0}let u=or({key:o,nodeType:"atom",peek:peekAtom,get:getAtom,set:setAtom,init:initAtom,invalidate:invalidateAtom,shouldDeleteConfigOnRelease:shouldDeleteConfigOnReleaseAtom,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:a});return u}function atom(e){let{...t}=e,n="default"in e?e.default:new Promise(()=>{});return oi(n)?atomWithFallback({...t,default:n}):baseAtom({...t,default:n})}function atomWithFallback(e){let t=atom({...e,default:ot,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof on?t:Recoil_nullthrows(e.persistence_UNSTABLE).validator(t,ot)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=n4({key:`${e.key}__withFallback`,get:({get:n})=>{let o=n(t);return o instanceof on?e.default:o},set:({set:e},n)=>e(t,n),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return oa(n.key,oo(e.key)),n}atom.value=e=>new n7(e);var of=atom;let MapCache=class MapCache{constructor(e){var t;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null==e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}};var oh=Object.freeze({__proto__:null,MapCache:{MapCache}.MapCache});let{LRUCache:op}=nV,{MapCache:o_}=oh,om={equality:"reference",eviction:"none",maxSize:1/0};function getValueMapper$1(e){switch(e){case"reference":return e=>e;case"value":return e=>Recoil_stableStringify(e)}throw err_1(`Unrecognized equality policy ${e}`)}function getCache(e,t,n){switch(e){case"keep-all":return new o_({mapKey:n});case"lru":return new op({mapKey:n,maxSize:Recoil_nullthrows(t)});case"most-recent":return new op({mapKey:n,maxSize:1})}throw err_1(`Unrecognized eviction policy ${e}`)}var Recoil_cacheFromPolicy=function({equality:e=om.equality,eviction:t=om.eviction,maxSize:n=om.maxSize}=om){let o=getValueMapper$1(e),r=getCache(t,n,o);return r};let{setConfigDeletionHandler:oy}=N,{setConfigDeletionHandler:oS}=N,ov=0;var Recoil_selectorFamily=function(e){var t,n;let o=Recoil_cacheFromPolicy({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;let r,a;try{r=o.get(t)}catch(t){throw err_1(`Problem with cache lookup for selector ${e.key}: ${t.message}`)}if(null!=r)return r;let i=`${e.key}__selectorFamily/${null!==(n=Recoil_stableStringify(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${ov++}`,myGet=n=>e.get(t)(n),l=e.cachePolicy_UNSTABLE,s="function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;if(null!=e.set){let n=e.set;a=n4({key:i,get:myGet,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:s})}else a=n4({key:i,get:myGet,cachePolicy_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:s});return o.set(t,a),oS(a.key,()=>{o.delete(t)}),a}};let oR=Recoil_selectorFamily({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}}),og=Recoil_selectorFamily({key:"__error",get:e=>()=>{throw err_1(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}}),{loadableWithError:ob,loadableWithPromise:oT,loadableWithValue:ow}=f;function concurrentRequests(e,t){let n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(let[r,a]of t.entries())try{n[r]=e(a)}catch(e){o[r]=e}return[n,o]}function isError(e){return null!=e&&!Recoil_isPromise(e)}function unwrapDependencies(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function wrapResults(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((e,n,o)=>({...e,[n]:t[o]}),{})}function wrapLoadables(e,t,n){let o=n.map((e,n)=>null==e?ow(t[n]):Recoil_isPromise(e)?oT(e):ob(e));return wrapResults(e,o)}function combineAsyncResultsWithSyncResults(e,t){return t.map((t,n)=>void 0===t?e[n]:t)}let oA=Recoil_selectorFamily({key:"__waitForNone",get:e=>({get:t})=>{let n=unwrapDependencies(e),[o,r]=concurrentRequests(t,n);return wrapLoadables(e,o,r)},dangerouslyAllowMutability:!0}),oE=Recoil_selectorFamily({key:"__waitForAny",get:e=>({get:t})=>{let n=unwrapDependencies(e),[o,r]=concurrentRequests(t,n);return r.some(e=>!Recoil_isPromise(e))?wrapLoadables(e,o,r):new Promise(t=>{for(let[n,a]of r.entries())Recoil_isPromise(a)&&a.then(a=>{o[n]=a,r[n]=void 0,t(wrapLoadables(e,o,r))}).catch(a=>{r[n]=a,t(wrapLoadables(e,o,r))})})},dangerouslyAllowMutability:!0}),oN=Recoil_selectorFamily({key:"__waitForAll",get:e=>({get:t})=>{let n=unwrapDependencies(e),[o,r]=concurrentRequests(t,n);if(r.every(e=>null==e))return wrapResults(e,o);let a=r.find(isError);if(null!=a)throw a;return Promise.all(r).then(t=>wrapResults(e,combineAsyncResultsWithSyncResults(o,t)))},dangerouslyAllowMutability:!0}),oL=Recoil_selectorFamily({key:"__waitForAllSettled",get:e=>({get:t})=>{let n=unwrapDependencies(e),[o,r]=concurrentRequests(t,n);return r.every(e=>!Recoil_isPromise(e))?wrapLoadables(e,o,r):Promise.all(r.map((e,t)=>Recoil_isPromise(e)?e.then(e=>{o[t]=e,r[t]=void 0}).catch(e=>{o[t]=void 0,r[t]=e}):null)).then(()=>wrapLoadables(e,o,r))},dangerouslyAllowMutability:!0}),oV=Recoil_selectorFamily({key:"__noWait",get:e=>({get:t})=>{try{return n4.value(ow(t(e)))}catch(e){return n4.value(Recoil_isPromise(e)?oT(e):ob(e))}},dangerouslyAllowMutability:!0}),{RecoilLoadable:oC}=f,{DefaultValue:ok}=N,{RecoilRoot:oI,useRecoilStoreID:oP}=tf,{isRecoilValue:oM}=g,{retentionZone:oU}=F,{freshSnapshot:oO}=ej,{useRecoilState:oD,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:oB,useRecoilStateLoadable:ox,useRecoilValue:oF,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:oz,useRecoilValueLoadable:oW,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:oG,useResetRecoilState:o$,useSetRecoilState:oH}={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:useRecoilInterface_DEPRECATED,useRecoilState,useRecoilStateLoadable,useRecoilValue,useRecoilValueLoadable,useResetRecoilState,useSetRecoilState,useSetUnvalidatedAtomValues,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,useRecoilState_TRANSITION_SUPPORT_UNSTABLE},{useGotoRecoilSnapshot:oK,useRecoilSnapshot:oq,useRecoilTransactionObserver:oj}=t5,{useRecoilCallback:oZ}=nv,{noWait:oY,waitForAll:oJ,waitForAllSettled:oX,waitForAny:oQ,waitForNone:o0}={waitForNone:oA,waitForAny:oE,waitForAll:oN,waitForAllSettled:oL,noWait:oV};var o1={DefaultValue:ok,isRecoilValue:oM,RecoilLoadable:oC,RecoilEnv:h,RecoilRoot:oI,useRecoilStoreID:oP,useRecoilBridgeAcrossReactRoots_UNSTABLE:function(){"MUTABLE_SOURCE"===t9().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");let e=t6().current;return t7(()=>function({children:t}){return s.createElement(t3,{store_INTERNAL:e},t)},[e])},atom:of,selector:n4,atomFamily:function(e){var t,n;let o=Recoil_cacheFromPolicy({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n,r;let a=o.get(t);if(null!=a)return a;let{cachePolicyForParams_UNSTABLE:i,...l}=e,s="default"in e?e.default:new Promise(()=>{}),u=of({...l,key:`${e.key}__${null!==(n=Recoil_stableStringify(t))&&void 0!==n?n:"void"}`,default:"function"==typeof s?s(t):s,retainedBy_UNSTABLE:"function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"==typeof e.effects?e.effects(t):"function"==typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!==(r=e.effects)&&void 0!==r?r:e.effects_UNSTABLE});return o.set(t,u),oy(u.key,()=>{o.delete(t)}),u}},selectorFamily:Recoil_selectorFamily,constSelector:function(e){return oR(e)},errorSelector:function(e){return og(e)},readOnlySelector:function(e){return e},noWait:oY,waitForNone:o0,waitForAny:oQ,waitForAll:oJ,waitForAllSettled:oX,useRecoilValue:oF,useRecoilValueLoadable:oW,useRecoilState:oD,useRecoilStateLoadable:ox,useSetRecoilState:oH,useResetRecoilState:o$,useGetRecoilValueInfo_UNSTABLE:function(){let e=t8();return({key:t})=>t4(e.current,e.current.getState().currentTree,t)},useRecoilRefresher_UNSTABLE:function(e){let t=nR();return nb(()=>{let n=t.current;ng(n,e)},[e,t])},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:oG,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:oz,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:oB,useRecoilCallback:oZ,useRecoilTransaction_UNSTABLE:function(e,t){let n=nw();return nA(()=>(...t)=>{let o=nT(n.current);o(n=>{e(n)(...t)})},null!=t?[...t,n]:void 0)},useGotoRecoilSnapshot:oK,useRecoilSnapshot:oq,useRecoilTransactionObserver_UNSTABLE:oj,snapshot_UNSTABLE:oO,useRetain:Recoil_useRetain,retentionZone:oU};o1.DefaultValue,o1.isRecoilValue,o1.RecoilLoadable;var o2=o1.RecoilEnv,o5=o1.RecoilRoot;o1.useRecoilStoreID,o1.useRecoilBridgeAcrossReactRoots_UNSTABLE;var o4=o1.atom,o8=o1.selector;o1.atomFamily,o1.selectorFamily,o1.constSelector,o1.errorSelector,o1.readOnlySelector,o1.noWait,o1.waitForNone,o1.waitForAny,o1.waitForAll,o1.waitForAllSettled;var o9=o1.useRecoilValue;o1.useRecoilValueLoadable;var o3=o1.useRecoilState;o1.useRecoilStateLoadable;var o6=o1.useSetRecoilState;o1.useResetRecoilState,o1.useGetRecoilValueInfo_UNSTABLE,o1.useRecoilRefresher_UNSTABLE,o1.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,o1.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,o1.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,o1.useRecoilCallback,o1.useRecoilTransaction_UNSTABLE,o1.useGotoRecoilSnapshot,o1.useRecoilSnapshot,o1.useRecoilTransactionObserver_UNSTABLE,o1.snapshot_UNSTABLE,o1.useRetain,o1.retentionZone}},function(e){var __webpack_exec__=function(t){return e(e.s=t)};e.O(0,[9774,179],function(){return __webpack_exec__(6840),__webpack_exec__(59974)}),_N_E=e.O()}]);